{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "multi-select-field",
  "type": "registry:block",
  "title": "Multi Select Field",
  "description": "A multiple selection component with validation",
  "files": [
    {
      "path": "registry/multi-select-field/component.tsx",
      "content": "import * as React from \"react\";\nimport { X, Check } from \"lucide-react\";\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { cn } from \"@/lib/utils\";\nimport { Badge } from \"@/components/ui/badge\";\nimport type { Option } from \"./schema\";\n\nconst sizeVariants = {\n  sm: \"h-8 text-xs\",\n  md: \"h-10 text-sm\",\n  lg: \"h-12 text-base\",\n};\n\nconst variantStyles = {\n  default:\n    \"border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n  outline:\n    \"border-2 border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n  ghost: \"border-0 bg-transparent hover:bg-accent hover:text-accent-foreground\",\n};\n\nexport interface MultiSelectProps {\n  options: Option[];\n  value: string[];\n  onChange: (value: string[]) => void;\n  placeholder?: string;\n  searchPlaceholder?: string;\n  disabled?: boolean;\n  className?: string;\n  size?: keyof typeof sizeVariants;\n  variant?: keyof typeof variantStyles;\n  maxSelectedDisplay?: number;\n  searchable?: boolean;\n  clearable?: boolean;\n  selectAllOption?: boolean;\n}\n\nexport function MultiSelect({\n  options,\n  value,\n  onChange,\n  placeholder = \"Select options...\",\n  searchPlaceholder = \"Search options...\",\n  disabled = false,\n  className,\n  size = \"md\",\n  variant = \"default\",\n  maxSelectedDisplay = 3,\n  searchable = false,\n  selectAllOption = false,\n}: MultiSelectProps) {\n  const [isOpen, setIsOpen] = React.useState(false);\n  const [searchTerm, setSearchTerm] = React.useState(\"\");\n\n  const filteredOptions = React.useMemo(() => {\n    if (!searchable || !searchTerm) return options;\n    return options.filter((option) =>\n      option.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n  }, [options, searchTerm, searchable]);\n\n  const handleSelect = (selectedValue: string) => {\n    const option = options.find((opt) => opt.value === selectedValue);\n    if (!option || option.disabled) return;\n\n    const isSelected = value.some((item) => item === selectedValue);\n    if (isSelected) {\n      onChange(value.filter((item) => item !== selectedValue));\n    } else {\n      onChange([...value, selectedValue]);\n    }\n  };\n\n  const handleSelectAll = () => {\n    const selectableOptions = options.filter((opt) => !opt.disabled);\n    const allSelected = selectableOptions.every((opt) =>\n      value.some((v) => v === opt.value)\n    );\n\n    if (allSelected) {\n      onChange([]);\n    } else {\n      onChange(selectableOptions.map((opt) => opt.value));\n    }\n  };\n\n  const handleRemove = (valueToRemove: string) => {\n    onChange(value.filter((item) => item !== valueToRemove));\n  };\n\n  return (\n    <div className=\"flex flex-col gap-2\">\n      <Select\n        open={isOpen}\n        onOpenChange={setIsOpen}\n        value={value[value.length - 1]}\n        onValueChange={handleSelect}\n      >\n        <SelectTrigger\n          className={cn(\n            sizeVariants[size],\n            variantStyles[variant],\n            \"w-full\",\n            className\n          )}\n          disabled={disabled}\n        >\n          <SelectValue>\n            {value.length === 0 ? (\n              <span className=\"text-muted-foreground\">{placeholder}</span>\n            ) : (\n              <span>{value.length} items selected</span>\n            )}\n          </SelectValue>\n        </SelectTrigger>\n        <SelectContent>\n          {searchable && (\n            <div className=\"p-2 border-b\">\n              <input\n                type=\"text\"\n                placeholder={searchPlaceholder}\n                value={searchTerm}\n                onChange={(e) => setSearchTerm(e.target.value)}\n                className=\"w-full px-2 py-1 text-sm border rounded focus:outline-none focus:ring-2\"\n                onClick={(e) => e.stopPropagation()}\n              />\n            </div>\n          )}\n          <SelectGroup>\n            {selectAllOption && (\n              <SelectItem value=\"__select_all__\" onClick={handleSelectAll}>\n                <div className=\"flex items-center\">\n                  <div className=\"mr-2 h-4 w-4 border rounded flex items-center justify-center\">\n                    {options.length === value.length && (\n                      <Check className=\"h-3 w-3\" />\n                    )}\n                  </div>\n                  Select All\n                </div>\n              </SelectItem>\n            )}\n            {filteredOptions.map((option) => (\n              <SelectItem\n                key={option.value}\n                value={option.value}\n                disabled={option.disabled}\n              >\n                <div className=\"flex items-center\">\n                  <div className=\"mr-2 h-4 w-4 border rounded flex items-center justify-center\">\n                    {value.some((item) => item === option.value) && (\n                      <Check className=\"h-3 w-3\" />\n                    )}\n                  </div>\n                  {option.name}\n                </div>\n              </SelectItem>\n            ))}\n          </SelectGroup>\n        </SelectContent>\n      </Select>\n\n      {value.length > 0 && (\n        <div className=\"flex gap-1 flex-wrap\">\n          {value.length > maxSelectedDisplay ? (\n            <>\n              <span className=\"mr-1\">{value.length} selected:</span>\n              {value.slice(0, maxSelectedDisplay).map((item, index) => (\n                <Badge\n                  key={index}\n                  variant=\"secondary\"\n                  className=\"mr-1 mb-1\"\n                  onClick={() => handleRemove(item)}\n                  onMouseDown={(e: React.MouseEvent) => e.stopPropagation()}\n                >\n                  <X className=\"ml-1 h-3 w-3\" />\n                </Badge>\n              ))}\n              <span className=\"text-muted-foreground\">...</span>\n            </>\n          ) : (\n            value.map((item) => (\n              <Badge\n                key={item}\n                variant=\"secondary\"\n                className=\"mr-1 mb-1\"\n                onClick={() => handleRemove(item)}\n                onMouseDown={(e: React.MouseEvent) => e.stopPropagation()}\n              >\n                {item}\n                <X className=\"ml-1 h-3 w-3\" />\n              </Badge>\n            ))\n          )}\n        </div>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "src/registry-components/multi-select-field/component.tsx"
    },
    {
      "path": "registry/multi-select-field/field.tsx",
      "content": "import * as React from \"react\";\nimport { useFormContext } from \"react-hook-form\";\nimport { MultiSelect } from \"./component\";\nimport { createMultiSelectSchema, Option } from \"./schema\";\nimport {\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\n\nexport interface MultiSelectFieldProps {\n  name: string;\n  label?: string;\n  options: Option[];\n  placeholder?: string;\n  searchPlaceholder?: string;\n  disabled?: boolean;\n  className?: string;\n  size?: \"sm\" | \"md\" | \"lg\";\n  variant?: \"default\" | \"outline\" | \"ghost\";\n  required?: boolean;\n  min?: number;\n  max?: number;\n  maxSelectedDisplay?: number;\n  searchable?: boolean;\n  clearable?: boolean;\n  selectAllOption?: boolean;\n  errorMessages?: {\n    required?: string;\n    min?: string;\n    max?: string;\n    invalid?: string;\n  };\n}\n\nexport function MultiSelectField({\n  name,\n  label,\n  options,\n  placeholder,\n  searchPlaceholder,\n  disabled,\n  className,\n  size,\n  variant,\n  required,\n  min,\n  max,\n  maxSelectedDisplay,\n  searchable,\n  clearable,\n  selectAllOption,\n  errorMessages,\n}: MultiSelectFieldProps) {\n  const form = useFormContext();\n\n  const schema = createMultiSelectSchema({\n    required,\n    min,\n    max,\n    errorMessages,\n  });\n\n  return (\n    <FormField\n      control={form.control}\n      name={name}\n      rules={{\n        validate: (val) => {\n          const result = schema.safeParse(val);\n          return result.success || result.error.errors[0]?.message;\n        },\n      }}\n      render={({ field }) => (\n        <FormItem className={className}>\n          {label && (\n            <FormLabel className=\"!text-foreground\">\n              {label} {required && <span className=\"text-destructive\">*</span>}\n            </FormLabel>\n          )}\n          <FormControl>\n            <MultiSelect\n              options={options}\n              value={field.value}\n              onChange={field.onChange}\n              placeholder={placeholder}\n              searchPlaceholder={searchPlaceholder}\n              disabled={disabled}\n              size={size}\n              variant={variant}\n              maxSelectedDisplay={maxSelectedDisplay}\n              searchable={searchable}\n              clearable={clearable}\n              selectAllOption={selectAllOption}\n            />\n          </FormControl>\n          <FormMessage />\n        </FormItem>\n      )}\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "src/registry-components/multi-select-field/field.tsx"
    },
    {
      "path": "registry/multi-select-field/schema.ts",
      "content": "import { z } from \"zod\";\n\nexport interface Option {\n  value: string;\n  name: string;\n  disabled?: boolean;\n}\n\nexport const createMultiSelectSchema = ({\n  required = false,\n  min,\n  max,\n  errorMessages = {},\n}: {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  errorMessages?: {\n    required?: string;\n    min?: string;\n    max?: string;\n    invalid?: string;\n  };\n} = {}) => {\n  const schema = z\n    .array(\n      z.object({\n        value: z.string(),\n        name: z.string(),\n        disabled: z.boolean().optional(),\n      })\n    )\n    .superRefine((val, ctx) => {\n      if (required && val.length === 0)\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: errorMessages.required ?? \"This field is required\",\n        });\n      if (min !== undefined && val.length < min)\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message:\n            errorMessages.min ?? `Please select at least ${min} option(s)`,\n        });\n      if (max !== undefined && val.length > max)\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message:\n            errorMessages.max ?? `Please select at most ${max} option(s)`,\n        });\n      if (errorMessages.invalid)\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: errorMessages.invalid,\n        });\n    });\n\n  return schema;\n};\n\nexport type MultiSelectSchema = z.infer<\n  ReturnType<typeof createMultiSelectSchema>\n>;\n",
      "type": "registry:hook",
      "target": "src/registry-components/multi-select-field/schema.ts"
    }
  ]
}